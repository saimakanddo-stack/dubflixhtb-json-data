name: Movie Database Management

on:
  schedule:
    - cron: '0 */4 * * *'
  
  workflow_dispatch:
    inputs:
      force_run:
        description: 'Force run even if no changes detected'
        required: false
        default: false
        type: boolean
  
  push:
    branches:
      - main
    paths:
      - 'data/movies.json'

jobs:
  manage-movie-database:
    runs-on: ubuntu-latest
    
    # ‡¶∂‡ßÅ‡¶ß‡ßÅ‡¶Æ‡¶æ‡¶§‡ßç‡¶∞ Main ‡¶¨‡ßç‡¶∞‡¶æ‡¶û‡ßç‡¶ö‡ßá ‡¶ï‡¶æ‡¶ú ‡¶ï‡¶∞‡¶¨‡ßá
    if: github.ref == 'refs/heads/main'
    
    steps:
    - name: Checkout repository
      uses: actions/checkout@v4
      with:
        fetch-depth: 0
        token: ${{ secrets.GITHUB_TOKEN }}

    - name: Setup Node.js
      uses: actions/setup-node@v4
      with:
        node-version: '20'

    - name: Process movie database
      id: process-movies
      run: |
        # ‡¶®‡ßã‡¶°‡¶ú‡ßá‡¶è‡¶∏ ‡¶∏‡ßç‡¶ï‡ßç‡¶∞‡¶ø‡¶™‡ßç‡¶ü ‡¶§‡ßà‡¶∞‡¶ø
        cat > process_movies.js << 'EOF'
        const fs = require('fs');
        const path = require('path');

        // ‡¶´‡¶æ‡¶á‡¶≤ ‡¶™‡ßú‡¶æ‡¶∞ ‡¶´‡¶æ‡¶Ç‡¶∂‡¶®
        function readMoviesFile(filePath) {
          try {
            if (!fs.existsSync(filePath)) {
              throw new Error(`File not found: ${filePath}`);
            }
            const content = fs.readFileSync(filePath, 'utf8');
            if (!content.trim()) {
              throw new Error('File is empty');
            }
            const parsed = JSON.parse(content);
            console.log(`‚úì File loaded successfully (${content.length} bytes)`);
            return parsed;
          } catch (error) {
            console.error(`‚úó Error reading file: ${error.message}`);
            return null;
          }
        }

        // ‡¶§‡¶æ‡¶∞‡¶ø‡¶ñ ‡¶´‡¶∞‡¶Æ‡ßá‡¶ü ‡¶°‡¶ø‡¶ü‡ßá‡¶ï‡ßç‡¶ü ‡¶ì ‡¶∞‡ßÇ‡¶™‡¶æ‡¶®‡ßç‡¶§‡¶∞‡ßá‡¶∞ ‡¶´‡¶æ‡¶Ç‡¶∂‡¶®
        function parseAndFormatDate(dateString) {
          if (!dateString || typeof dateString !== 'string') {
            return null;
          }
          
          const trimmedDate = dateString.trim();
          if (!trimmedDate) return null;
          
          // ‡¶á‡¶§‡¶ø‡¶Æ‡¶ß‡ßç‡¶Ø‡ßá ISO ‡¶´‡¶∞‡¶Æ‡ßá‡¶ü‡ßá ‡¶•‡¶æ‡¶ï‡¶≤‡ßá ‡¶≠‡ßç‡¶Ø‡¶æ‡¶≤‡¶ø‡¶°‡ßá‡¶ü ‡¶ï‡¶∞‡ßÅ‡¶®
          const isoRegex = /^\d{4}-\d{2}-\d{2}T\d{2}:\d{2}:\d{2}(\.\d{3})?Z$/i;
          if (isoRegex.test(trimmedDate)) {
            const date = new Date(trimmedDate);
            return !isNaN(date.getTime()) ? date.toISOString().replace(/\.\d{3}Z$/, 'Z') : null;
          }
          
          // ‡¶™‡ßç‡¶Ø‡¶æ‡¶ü‡¶æ‡¶∞‡ßç‡¶®‡ßá‡¶∞ ‡¶§‡¶æ‡¶≤‡¶ø‡¶ï‡¶æ
          const patterns = [
            // YYYY-MM-DD
            { regex: /^(\d{4})-(\d{2})-(\d{2})$/, handler: (m) => `${m[1]}-${m[2]}-${m[3]}T00:00:00Z` },
            // DD-MM-YYYY
            { regex: /^(\d{2})-(\d{2})-(\d{4})$/, handler: (m) => `${m[3]}-${m[2]}-${m[1]}T00:00:00Z` },
            // DD/MM/YYYY
            { regex: /^(\d{2})\/(\d{2})\/(\d{4})$/, handler: (m) => `${m[3]}-${m[2]}-${m[1]}T00:00:00Z` },
            // YYYY/MM/DD
            { regex: /^(\d{4})\/(\d{2})\/(\d{2})$/, handler: (m) => `${m[1]}-${m[2]}-${m[3]}T00:00:00Z` },
            // MM-DD-YYYY
            { regex: /^(\d{2})-(\d{2})-(\d{4})$/, handler: (m) => `${m[3]}-${m[1]}-${m[2]}T00:00:00Z` },
          ];
          
          let parsedDate = null;
          
          // ‡¶™‡ßç‡¶Ø‡¶æ‡¶ü‡¶æ‡¶∞‡ßç‡¶® ‡¶Æ‡¶ø‡¶≤‡ßá ‡¶ï‡¶ø‡¶®‡¶æ ‡¶ö‡ßá‡¶ï ‡¶ï‡¶∞‡ßÅ‡¶®
          for (const pattern of patterns) {
            const match = trimmedDate.match(pattern.regex);
            if (match) {
              try {
                const isoString = pattern.handler(match);
                parsedDate = new Date(isoString);
                if (!isNaN(parsedDate.getTime())) {
                  break;
                }
              } catch (e) {
                // ‡¶™‡¶∞‡¶¨‡¶∞‡ßç‡¶§‡ßÄ ‡¶™‡ßç‡¶Ø‡¶æ‡¶ü‡¶æ‡¶∞‡ßç‡¶® ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ ‡¶ï‡¶∞‡ßÅ‡¶®
              }
            }
          }
          
          // Month DD, YYYY ‡¶´‡¶∞‡¶Æ‡ßá‡¶ü ‡¶ö‡ßá‡¶ï
          if (!parsedDate || isNaN(parsedDate.getTime())) {
            const monthNames = [
              'January', 'February', 'March', 'April', 'May', 'June',
              'July', 'August', 'September', 'October', 'November', 'December'
            ];
            
            const monthPattern = monthNames.join('|');
            const regex = new RegExp(`^(${monthPattern})[\\s,]+(\\d{1,2})(?:st|nd|rd|th)?[\\s,]+(\\d{4})$`, 'i');
            const match = trimmedDate.match(regex);
            
            if (match) {
              try {
                const [_, monthName, day, year] = match;
                const monthIndex = monthNames.findIndex(m => 
                  m.toLowerCase() === monthName.toLowerCase());
                if (monthIndex !== -1) {
                  const monthStr = (monthIndex + 1).toString().padStart(2, '0');
                  const dayStr = day.padStart(2, '0');
                  parsedDate = new Date(`${year}-${monthStr}-${dayStr}T00:00:00Z`);
                }
              } catch (e) {
                // Error, continue
              }
            }
          }
          
          // ‡¶∏‡¶∞‡ßç‡¶¨‡¶∂‡ßá‡¶∑ ‡¶ö‡ßá‡¶∑‡ßç‡¶ü‡¶æ: JavaScript Date constructor
          if (!parsedDate || isNaN(parsedDate.getTime())) {
            try {
              parsedDate = new Date(trimmedDate);
            } catch (e) {
              console.warn(`Could not parse date: "${dateString}"`);
              return null;
            }
          }
          
          return !isNaN(parsedDate.getTime()) ? 
            parsedDate.toISOString().replace(/\.\d{3}Z$/, 'Z') : 
            null;
        }

        // ‡¶§‡¶æ‡¶∞‡¶ø‡¶ñ‡ßá‡¶∞ ‡¶™‡¶æ‡¶∞‡ßç‡¶•‡¶ï‡ßç‡¶Ø ‡¶ó‡¶£‡¶®‡¶æ (‡¶¶‡¶ø‡¶®‡ßá)
        function getDaysDifference(isoDate) {
          if (!isoDate) return Infinity;
          
          try {
            const date = new Date(isoDate);
            const now = new Date();
            
            // ‡¶Æ‡¶ø‡¶≤‡¶ø‡¶∏‡ßá‡¶ï‡ßá‡¶®‡ßç‡¶° ‡¶™‡¶æ‡¶∞‡ßç‡¶•‡¶ï‡ßç‡¶Ø
            const diffTime = now.getTime() - date.getTime();
            const daysDiff = diffTime / (1000 * 60 * 60 * 24);
            
            // ‡¶≠‡¶¨‡¶ø‡¶∑‡ßç‡¶Ø‡¶§‡ßá‡¶∞ ‡¶§‡¶æ‡¶∞‡¶ø‡¶ñ ‡¶¨‡¶æ ‡¶≠‡ßÅ‡¶≤ ‡¶§‡¶æ‡¶∞‡¶ø‡¶ñ ‡¶π‡¶≤‡ßá Infinity
            if (isNaN(daysDiff) || daysDiff < 0) {
              return Infinity;
            }
            
            return Math.floor(daysDiff);
          } catch (e) {
            console.warn(`Warning: Could not calculate days difference for ${isoDate}: ${e.message}`);
            return Infinity;
          }
        }

        // ‡¶Æ‡ßÅ‡¶≠‡¶ø ‡¶≤‡ßá‡¶¨‡ßá‡¶≤ ‡¶Ü‡¶™‡¶°‡ßá‡¶ü
        function updateMovieLabels(movie) {
          const updatedMovie = { ...movie };
          const currentLabel = updatedMovie.info1_custom || '';
          
          const daysSinceCreation = getDaysDifference(updatedMovie.createdAt);
          const hasLastUpdated = updatedMovie.lastUpdated && updatedMovie.lastUpdated !== updatedMovie.createdAt;
          const daysSinceUpdate = hasLastUpdated ? getDaysDifference(updatedMovie.lastUpdated) : Infinity;
          
          // ‡¶≤‡ßá‡¶¨‡ßá‡¶≤ ‡¶∞‡¶ø‡¶Æ‡ßÅ‡¶≠ ‡¶ï‡¶∞‡¶æ ‡¶™‡ßç‡¶∞‡¶Ø‡¶º‡ßã‡¶ú‡¶® ‡¶ï‡¶ø‡¶®‡¶æ
          if (currentLabel === 'NEW' && daysSinceCreation > 7) {
            updatedMovie.info1_custom = '';
            return { movie: updatedMovie, changed: true };
          }
          
          if (currentLabel === 'UPDATED' && daysSinceUpdate > 10) {
            updatedMovie.info1_custom = '';
            return { movie: updatedMovie, changed: true };
          }
          
          // ‡¶®‡¶§‡ßÅ‡¶® ‡¶≤‡ßá‡¶¨‡ßá‡¶≤ ‡¶∏‡ßá‡¶ü ‡¶ï‡¶∞‡¶æ ‡¶™‡ßç‡¶∞‡¶Ø‡¶º‡ßã‡¶ú‡¶® ‡¶ï‡¶ø‡¶®‡¶æ
          const hasNoLabel = !currentLabel || currentLabel === '';
          
          if (hasNoLabel) {
            if (daysSinceCreation <= 7) {
              updatedMovie.info1_custom = 'NEW';
              return { movie: updatedMovie, changed: true };
            } else if (hasLastUpdated && daysSinceUpdate <= 10) {
              updatedMovie.info1_custom = 'UPDATED';
              return { movie: updatedMovie, changed: true };
            }
          }
          
          return { movie: updatedMovie, changed: false };
        }

        // ‡¶Æ‡ßÅ‡¶≠‡¶ø ‡¶™‡ßç‡¶∞‡¶∏‡ßá‡¶∏‡¶ø‡¶Ç
        function processMovies(data) {
          let movies = [];
          let isWrapped = false;
          let wrapperData = {};
          
          // ‡¶°‡ßá‡¶ü‡¶æ ‡¶∏‡ßç‡¶ü‡ßç‡¶∞‡¶æ‡¶ï‡¶ö‡¶æ‡¶∞ ‡¶°‡¶ø‡¶ü‡ßá‡¶ï‡ßç‡¶ü
          if (Array.isArray(data)) {
            movies = data.map(m => ({ ...m }));
          } else if (data && typeof data === 'object' && Array.isArray(data.movies)) {
            movies = data.movies.map(m => ({ ...m }));
            isWrapped = true;
            wrapperData = { ...data };
            delete wrapperData.movies;
          } else {
            throw new Error('Invalid JSON structure. Expected array or object with "movies" array');
          }
          
          console.log(`Processing ${movies.length} movies...`);
          
          let hasChanges = false;
          let dateFormatChanges = 0;
          let labelChanges = 0;
          
          // ‡¶§‡¶æ‡¶∞‡¶ø‡¶ñ ‡¶´‡¶∞‡¶Æ‡ßá‡¶ü ‡¶Ü‡¶™‡¶°‡ßá‡¶ü
          const moviesWithFormattedDates = movies.map(movie => {
            const newMovie = { ...movie };
            let changed = false;
            
            ['createdAt', 'lastUpdated'].forEach(field => {
              if (newMovie[field]) {
                const formattedDate = parseAndFormatDate(newMovie[field]);
                if (formattedDate && formattedDate !== newMovie[field]) {
                  newMovie[field] = formattedDate;
                  changed = true;
                  dateFormatChanges++;
                }
              }
            });
            
            if (changed) hasChanges = true;
            return newMovie;
          });
          
          // ‡¶≤‡ßá‡¶¨‡ßá‡¶≤ ‡¶Ü‡¶™‡¶°‡ßá‡¶ü
          const moviesWithUpdatedLabels = moviesWithFormattedDates.map(movie => {
            const result = updateMovieLabels(movie);
            if (result.changed) {
              hasChanges = true;
              labelChanges++;
            }
            return result.movie;
          });
          
          // ‡¶∏‡¶æ‡¶ú‡¶æ‡¶®‡ßã (‡¶®‡¶§‡ßÅ‡¶® ‡¶•‡ßá‡¶ï‡ßá ‡¶™‡ßÅ‡¶∞‡¶æ‡¶§‡¶®)
          const originalOrder = moviesWithUpdatedLabels.map(m => JSON.stringify(m));
          
          const sortedMovies = [...moviesWithUpdatedLabels].sort((a, b) => {
            const getTime = (movie) => {
              const dateStr = movie.lastUpdated || movie.createdAt;
              return dateStr ? new Date(dateStr).getTime() : 0;
            };
            return getTime(b) - getTime(a); // Descending order
          });
          
          // ‡¶∏‡¶æ‡¶ú‡¶æ‡¶®‡ßã‡¶§‡ßá ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶π‡ßü‡ßá‡¶õ‡ßá ‡¶ï‡¶ø‡¶®‡¶æ
          const newOrder = sortedMovies.map(m => JSON.stringify(m));
          const orderChanged = originalOrder.join('|') !== newOrder.join('|');
          if (orderChanged) {
            hasChanges = true;
            console.log(`‚úì Order changed after sorting`);
          }
          
          // ‡¶´‡¶æ‡¶á‡¶®‡¶æ‡¶≤ ‡¶°‡ßá‡¶ü‡¶æ ‡¶™‡ßç‡¶∞‡¶∏‡ßç‡¶§‡ßÅ‡¶§
          let finalData;
          if (isWrapped) {
            finalData = { ...wrapperData, movies: sortedMovies };
          } else {
            finalData = sortedMovies;
          }
          
          // ‡¶™‡¶∞‡¶ø‡¶∏‡¶Ç‡¶ñ‡ßç‡¶Ø‡¶æ‡¶®
          console.log(`\nüìä Processing Summary:`);
          console.log(`  Total movies: ${movies.length}`);
          console.log(`  Date format changes: ${dateFormatChanges}`);
          console.log(`  Label changes: ${labelChanges}`);
          console.log(`  Order changed: ${orderChanged ? 'Yes' : 'No'}`);
          console.log(`  Overall changes: ${hasChanges ? 'Yes' : 'No'}`);
          
          return {
            data: finalData,
            hasChanges,
            stats: {
              totalMovies: movies.length,
              dateFormatChanges,
              labelChanges,
              orderChanged
            }
          };
        }

        // ‡¶Æ‡ßÇ‡¶≤ ‡¶è‡¶ï‡ßç‡¶∏‡¶ø‡¶ï‡¶ø‡¶â‡¶∂‡¶®
        (function main() {
          try {
            const filePath = path.join(process.cwd(), 'data', 'movies.json');
            console.log(`üìÅ Reading file: ${filePath}`);
            
            // ‡¶´‡¶æ‡¶á‡¶≤ ‡¶™‡¶°‡¶º‡ßÅ‡¶®
            const originalData = readMoviesFile(filePath);
            if (!originalData) {
              console.error('‚ùå Failed to load movies.json');
              process.exit(1);
            }
            
            // ‡¶™‡ßç‡¶∞‡¶∏‡ßá‡¶∏‡¶ø‡¶Ç
            const result = processMovies(originalData);
            
            // ‡¶™‡¶∞‡¶ø‡¶¨‡¶∞‡ßç‡¶§‡¶® ‡¶•‡¶æ‡¶ï‡¶≤‡ßá ‡¶∏‡ßá‡¶≠ ‡¶ï‡¶∞‡ßÅ‡¶®
            if (result.hasChanges) {
              // ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ï‡¶Ü‡¶™ ‡¶§‡ßà‡¶∞‡¶ø (‡¶ü‡ßá‡¶Æ‡ßç‡¶™‡ßã‡¶∞‡¶æ‡¶∞‡¶ø)
              const backupPath = path.join(process.cwd(), 'data', `movies_backup_${Date.now()}.json`);
              fs.writeFileSync(backupPath, JSON.stringify(originalData, null, 2));
              console.log(`üì¶ Backup created: ${backupPath}`);
              
              // ‡¶®‡¶§‡ßÅ‡¶® ‡¶°‡ßá‡¶ü‡¶æ ‡¶∏‡ßá‡¶≠
              fs.writeFileSync(filePath, JSON.stringify(result.data, null, 2));
              console.log('‚úÖ Movie database updated successfully');
              
              // GitHub Actions output
              const outputFile = process.env.GITHUB_OUTPUT;
              if (outputFile) {
                fs.appendFileSync(outputFile, `has_changes=true\n`);
                fs.appendFileSync(outputFile, `changes_summary=Processed ${result.stats.totalMovies} movies: ${result.stats.dateFormatChanges} date formats, ${result.stats.labelChanges} labels, order ${result.stats.orderChanged ? 'updated' : 'unchanged'}\n`);
              }
            } else {
              console.log('‚úÖ No changes needed');
              
              const outputFile = process.env.GITHUB_OUTPUT;
              if (outputFile) {
                fs.appendFileSync(outputFile, `has_changes=false\n`);
                fs.appendFileSync(outputFile, `changes_summary=No changes needed for ${result.stats.totalMovies} movies\n`);
              }
            }
            
            console.log('üéâ Processing completed successfully');
            
          } catch (error) {
            console.error(`‚ùå Fatal error: ${error.message}`);
            console.error(error.stack);
            process.exit(1);
          }
        })();
        EOF

        # Node.js ‡¶∏‡ßç‡¶ï‡ßç‡¶∞‡¶ø‡¶™‡ßç‡¶ü ‡¶è‡¶ï‡ßç‡¶∏‡¶ø‡¶ï‡¶ø‡¶â‡¶ü
        echo "üöÄ Starting movie database processor..."
        node process_movies.js
        
        # git diff ‡¶¶‡¶ø‡ßü‡ßá ‡¶®‡¶ø‡¶∂‡ßç‡¶ö‡¶ø‡¶§ ‡¶ï‡¶∞‡ßÅ‡¶®
        echo -e "\nüîç Verifying changes with git diff..."
        if git diff --no-ext-diff --quiet data/movies.json; then
          echo "‚ÑπÔ∏è Git confirms: No changes in movies.json"
          # ‡¶Ø‡¶¶‡¶ø Node ‡¶∏‡ßç‡¶ï‡ßç‡¶∞‡¶ø‡¶™‡ßç‡¶ü ‡¶¨‡¶≤‡ßá‡¶õ‡ßá changes ‡¶Ü‡¶õ‡ßá ‡¶ï‡¶ø‡¶®‡ßç‡¶§‡ßÅ git diff ‡¶¨‡¶≤‡¶õ‡ßá ‡¶®‡¶æ, ‡¶§‡¶æ‡¶π‡¶≤‡ßá Node ‡¶∏‡ßç‡¶ï‡ßç‡¶∞‡¶ø‡¶™‡ßç‡¶ü‡¶ï‡ßá ‡¶Æ‡¶æ‡¶®‡ßç‡¶Ø ‡¶ï‡¶∞‡ßÅ‡¶®
          if ! grep -q "has_changes=false" "$GITHUB_OUTPUT" 2>/dev/null; then
            echo "‚ö†Ô∏è Node script reported changes but git diff doesn't show any. Using Node script result."
          fi
        else
          echo "‚úÖ Git confirms: Changes detected in movies.json"
          # git diff ‡¶¶‡ßá‡¶ñ‡¶æ‡¶® (limited output)
          echo "=== Preview of changes ==="
          git diff --no-color data/movies.json | head -30
        fi
        
        # ‡¶ü‡ßá‡¶Æ‡ßç‡¶™‡ßã‡¶∞‡¶æ‡¶∞‡¶ø ‡¶¨‡ßç‡¶Ø‡¶æ‡¶ï‡¶Ü‡¶™ ‡¶´‡¶æ‡¶á‡¶≤ ‡¶°‡¶ø‡¶≤‡¶ø‡¶ü
        rm -f data/movies_backup_*.json 2>/dev/null || true

    - name: Commit and Push changes
      id: commit-changes
      if: steps.process-movies.outputs.has_changes == 'true' || github.event.inputs.force_run == 'true'
      run: |
        echo "üìù Configuring git..."
        
        # Git ‡¶ï‡¶®‡¶´‡¶ø‡¶ó‡¶æ‡¶∞
        git config --local user.email "github-actions[bot]@users.noreply.github.com"
        git config --local user.name "github-actions[bot]"
        
        # Stage changes
        echo "üì¶ Staging changes..."
        git add data/movies.json
        
        # Check if there are staged changes
        if git diff --cached --quiet; then
          echo "‚ÑπÔ∏è No staged changes to commit"
          echo "no_commit=true" >> $GITHUB_OUTPUT
          exit 0
        fi
        
        echo "üíæ Creating commit..."
        
        # Commit message
        COMMIT_MESSAGE="ü§ñ Auto-update movie database
        
        ${{ steps.process-movies.outputs.changes_summary }}
        
        Automated by GitHub Actions
        Workflow run: #${{ github.run_number }}"
        
        # Commit
        git commit -m "$COMMIT_MESSAGE"
        echo "‚úÖ Changes committed"
        
        echo "üöÄ Pushing to main branch..."
        
        # Pull latest changes with rebase
        git fetch origin
        git rebase origin/main || {
          echo "‚ö†Ô∏è Rebase conflict detected, trying merge strategy..."
          git rebase --abort 2>/dev/null || true
          git fetch origin
          git merge origin/main --no-edit || {
            echo "‚ùå Could not merge changes. Manual intervention required."
            exit 1
          }
        }
        
        # Push changes
        git push origin main
        echo "‚úÖ Changes pushed successfully"
        echo "no_commit=false" >> $GITHUB_OUTPUT
        
      env:
        GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

    - name: Create workflow summary
      if: always()
      run: |
        echo "## üé¨ Movie Database Management" >> $GITHUB_STEP_SUMMARY
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # ‡¶ü‡ßç‡¶∞‡¶ø‡¶ó‡¶æ‡¶∞ ‡¶§‡¶•‡ßç‡¶Ø
        echo "**Trigger:** \`${{ github.event_name }}\`" >> $GITHUB_STEP_SUMMARY
        if github.event_name == 'workflow_dispatch' && github.event.inputs.force_run == 'true'; then
          echo "**Mode:** Forced run" >> $GITHUB_STEP_SUMMARY
        fi
        echo "" >> $GITHUB_STEP_SUMMARY
        
        # ‡¶™‡ßç‡¶∞‡¶∏‡ßá‡¶∏‡¶ø‡¶Ç ‡¶∞‡ßá‡¶ú‡¶æ‡¶≤‡ßç‡¶ü
        if [[ "${{ steps.process-movies.outputs.has_changes }}" == "true" ]]; then
          echo "### ‚úÖ Database Updated" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "${{ steps.process-movies.outputs.changes_summary }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [[ "${{ steps.commit-changes.outputs.no_commit }}" == "false" ]]; then
            echo "**‚úÖ Changes committed to main branch**" >> $GITHUB_STEP_SUMMARY
          elif [[ "${{ steps.commit-changes.outputs.no_commit }}" == "true" ]]; then
            echo "**‚ÑπÔ∏è No changes to commit (already up-to-date)**" >> $GITHUB_STEP_SUMMARY
          else
            echo "**üîß Changes were made but not committed**" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Performed actions:**" >> $GITHUB_STEP_SUMMARY
          echo "- üìÖ Date format standardization (ISO 8601)" >> $GITHUB_STEP_SUMMARY
          echo "- üè∑Ô∏è Status label updates (NEW ‚â§7d, UPDATED ‚â§10d)" >> $GITHUB_STEP_SUMMARY
          echo "- üîÑ Chronological sorting (newest first)" >> $GITHUB_STEP_SUMMARY
          
        else
          echo "### ‚úÖ Database Up-to-Date" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "${{ steps.process-movies.outputs.changes_summary }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "**Status:** All movies are already properly formatted and sorted." >> $GITHUB_STEP_SUMMARY
        fi
        
        # Error ‡¶π‡¶≤‡ßá
        if failure(); then
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "### ‚ùå Processing Failed" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "The workflow encountered an error. Please check the logs for details." >> $GITHUB_STEP_SUMMARY
        fi
        
        echo "" >> $GITHUB_STEP_SUMMARY
        echo "---" >> $GITHUB_STEP_SUMMARY
        echo "**Details**" >> $GITHUB_STEP_SUMMARY
        echo "- Repository: \`${{ github.repository }}\`" >> $GITHUB_STEP_SUMMARY
        echo "- Branch: \`${{ github.ref_name }}\`" >> $GITHUB_STEP_SUMMARY
        echo "- Run: [#${{ github.run_number }}](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})" >> $GITHUB_STEP_SUMMARY
        echo "- Timestamp: $(date -u '+%Y-%m-%d %H:%M:%S UTC')" >> $GITHUB_STEP_SUMMARY
        
        # ‡¶ü‡ßç‡¶∞‡¶ø‡¶ó‡¶æ‡¶∞ ‡¶∏‡ßã‡¶∞‡ßç‡¶∏
        if github.event_name == 'push' && github.event.head_commit; then
          echo "- Triggered by: [\`${GITHUB_SHA::7}\`](${{ github.event.head_commit.url }})" >> $GITHUB_STEP_SUMMARY
          echo "- Commit message: ${{ github.event.head_commit.message }}" >> $GITHUB_STEP_SUMMARY
        fi
